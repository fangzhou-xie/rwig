% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sinkhorn.R
\name{sinkhorn}
\alias{sinkhorn}
\title{Sinkhorn algorithm}
\usage{
sinkhorn(
  a,
  b,
  C,
  sinkhorn_control = list(reg = 0.1, with_grad = FALSE, method = "auto", threshold = 0.1,
    max_iter = 1000L, zero_tol = 1e-06, verbose = 0L)
)
}
\arguments{
\item{a}{numeric vector, source discrete density (probability vector)}

\item{b}{numeric vector, target discrete density (probability vector)}

\item{C}{numeric matrix, cost matrix between source and target}

\item{sinkhorn_control}{list, control parameters for the computation
\itemize{
\item reg double, regularization parameter (default = .1)
\item with_grad: bool, whether to calculate the gradient w.r.t. a
\item n_threads: int, number of threads (only used for \code{method = "log"},
ignored by the \code{method = "vanilla"}, default = 0)
\item method: character, which method to use: "auto", "vanilla", "log"
"auto" with try to calculate minimum value of the Gibbs kernel K
and switch to \code{method = "log"} if the minimum value is less than \code{threshold}
(default = "auto")
\item threshold: double, threshold value below which "auto" method
will default to \code{method = "log"} for stablized computation in log-domain
(default = .1)
\item max_iter: int, maximum iteration of \code{\link{sinkhorn}} algorithm
(default = 1000)
\item zero_tol: double, determine covergence (default = 1e-6)
\item verbose: int, print out debug info for the algorithm for every
\code{verbose} iteration (default to 0, i.e. not printing anything)
}}
}
\value{
list of results
\itemize{
\item P: optimal coupling matrix
\item grad_a: gradient of loss w.r.t. \code{a} (only with \code{with_grad = TRUE})
\item u, v: scaling vectors
\item loss: regularized loss
\item iter: iterations of the algorithm
\item err: condition for convergence
\item return_status: 0 (convergence), 1 (max iteration reached), 2 (other)
}
}
\description{
Sinkhorn algorithm to solve entropy-regularized Optimal Transport
problems.
}
\details{
This is the general function to solve the OT problem,
and it will use either vanilla (\code{method = "vanilla"}) or
log-stabilized Sinkhorn algorithm (\code{method = "log"})
for solving the problem.
}
\examples{
# simple sinkhorn example
a <- c(.3, .4, .1, .1, .1)
b <- c(.4, .5, .1)
C <- rbind(
  c(.1, .2, .3),
  c(.2, .3, .4),
  c(.4, .3, .2),
  c(.3, .2, .1),
  c(.5, .5, .4)
)
reg <- .1
sol <- sinkhorn(a, b, C, sinkhorn_control = list(reg = reg, verbose = 0))

# you can also supply arguments to control the computation
# for example, calculate the gradient w.r.t. a
sol <- sinkhorn(a, b, C,
sinkhorn_control = list(reg = reg, with_grad = TRUE, verbose = 0))

}
\references{
Peyré, G., & Cuturi, M. (2019). Computational Optimal Transport:
With Applications to Data Science.
\emph{Foundations and Trends® in Machine Learning}, 11(5–6), 355–607.
https://doi.org/10.1561/2200000073

Xie, F. (2025). Deriving the Gradients of Some Popular Optimal
Transport Algorithms (No. arXiv:2504.08722). \emph{arXiv}.
https://doi.org/10.48550/arXiv.2504.08722
}
\concept{Sinkhorn algorithms}
